{"name":"Selene","tagline":"Simple C++11 friendly header-only bindings to Lua","body":"Simple C++11 friendly header-only bindings to Lua 5.2+.\r\n\r\n## Requirements\r\n\r\n- Cmake 2.8+ to build the tests\r\n- Lua 5.1+\r\n- C++11 compliant compiler\r\n\r\n## Usage\r\n\r\nSelene is a headers-only library so you just need to include\r\n\"selene.h\" to use this project.\r\n\r\nTo build the tests, do the following:\r\n\r\n```\r\nmkdir build\r\ncd build\r\ncmake ..\r\nmake\r\n```\r\n\r\nThis will build a `test` executable that you can run.\r\n\r\n## Usage\r\n\r\n### Establishing Lua Context\r\n\r\n```c++\r\nusing namespace sel;\r\nState state; // creates a Lua context\r\nState state{true}; // creates a Lua context and loads standard Lua libraries\r\n```\r\n\r\nWhen a `sel::State` object goes out of scope, the Lua context is\r\nautomatically destroyed in addition to all objects associated with it\r\n(including C++ objects).\r\n\r\n### Accessing elements\r\n\r\n```lua\r\n-- test.lua\r\nfoo = 4\r\nbar = {}\r\nbar[3] = \"hi\"\r\nbar[\"key\"] = \"there\"\r\n```\r\n\r\n```c++\r\nsel::State state;\r\nstate.Load(\"/path/to/test.lua\");\r\nassert(state[\"foo\"] == 4);\r\nassert(state[\"bar\"][3] == \"hi\");\r\nassert(state[\"bar\"][\"key\"] == \"there\");\r\n```\r\n\r\nWhen the `[]` operator is invoked on a `sel::State` object, a\r\n`sel::Selector` object is returned. The `Selector` is type castable to\r\nall the basic types that Lua can return.\r\n\r\nIf you access the same element frequently, it is recommended that you\r\ncache the selector for fast access later like so:\r\n\r\n```c++\r\nauto bar3 = state[\"bar\"][3]; // bar3 has type sel::Selector\r\nbar3 = 4;\r\nbar3 = 6;\r\nstd::cout << int(bar3) << std::endl;\r\n```\r\n\r\n### Calling Lua functions from C++\r\n\r\n```lua\r\n-- test.lua\r\n\r\nfunction foo()\r\nend\r\n\r\nfunction add(a, b)\r\n  return a + b\r\nend\r\n\r\nfunction sum_and_difference(a, b)\r\n  return (a+b), (a-b);\r\nend\r\n\r\nfunction bar()\r\n  return 4, true, \"hi\"\r\nend\r\n\r\nmytable = {}\r\nfunction mytable.foo()\r\n    return 4\r\nend\r\n```\r\n\r\n```c++\r\nsel::State state;\r\nstate.Load(\"/path/to/test.lua\");\r\n\r\n// Call function with no arguments or returns\r\nstate[\"foo\"]();\r\n\r\n// Call function with two arguments that returns an int\r\n// The type parameter can be one of int, lua_Number, std::string,\r\n// bool, or unsigned int\r\nint result = state[\"add\"](5, 2);\r\nassert(result == 7);\r\n\r\n\r\n// Call function that returns multiple values\r\nint sum, difference;\r\nsel::tie(sum, difference) = state[\"sum_and_difference\"](3, 1);\r\nassert(sum == 4 && difference == 2);\r\n\r\n// Call function in table\r\nresult = state[\"mytable\"][\"foo\"]();\r\nassert(result == 4);\r\n```\r\n\r\nNote that multi-value returns must have `sel::tie`\r\non the LHS and not `std::tie`. This will create a `sel::Tuple` as\r\nopposed to an `std::tuple` which has the `operator=` implemented for\r\nthe selector type.\r\n\r\n### Calling Free-standing C++ functions from Lua\r\n\r\n```c++\r\nint my_multiply(int a, int b) {\r\n    return (a*b);\r\n}\r\n\r\nsel::State state;\r\n\r\n// Register the function to the Lua global \"c_multiply\"\r\nstate[\"c_multiply\"] = &my_multiply;\r\n\r\n// Now we can call it (we can also call it from within lua)\r\nint result = state[\"c_multiply\"](5, 2);\r\nassert(result == 10);\r\n```\r\n\r\nYou can also register functor objects, lambdas, and any fully\r\nqualified `std::function`. See `test/interop_tests.h` for details.\r\n\r\n#### Accepting Lua functions as Arguments\r\n\r\nTo retrieve a Lua function as a callable object in C++, you can use\r\nthe `sel::function` type like so:\r\n\r\n```lua\r\n-- test.lua\r\n\r\nfunction add(a, b)\r\n    return a+b\r\nend\r\n\r\nfunction pass_add(x, y)\r\n    take_fun_arg(add, x, y)\r\nend\r\n```\r\n\r\n```c++\r\nint take_fun_arg(sel::function<int(int, int)> fun, int a, int b) {\r\n    return fun(a, b);\r\n}\r\n\r\nsel::State state;\r\nstate[\"take_fun_arg\"] = &take_fun_arg;\r\nstate.Load(\"test.lua\");\r\nassert(state[\"pass_add\"](3, 5) == 8)\r\n```\r\n\r\nThe `sel::function` type is pretty much identical to the\r\n`std::function` type excepts it holds a `shared_ptr` to a Lua\r\nreference. Once all instances of a particular `sel::function` go out\r\nof scope, the Lua reference will automatically become unbound. Simply\r\ncopying and retaining an instance of a `sel::function` will allow it\r\nto be callable later. You can also return a `sel::function` which will\r\nthen be callable in C++ or Lua.\r\n\r\n### Running arbitrary code\r\n\r\n```c++\r\nsel::State state;\r\nstate(\"x = 5\");\r\n```\r\n\r\nAfter running this snippet, `x` will have value 5 in the Lua runtime.\r\nSnippets run in this way cannot return anything to the caller at this time.\r\n\r\n### Registering Classes\r\n\r\n```c++\r\nstruct Bar {\r\n    int x;\r\n    Bar(int x_) : x(x_) {}\r\n    int AddThis(int y) { return x + y; }\r\n};\r\n\r\nsel::State state;\r\nstate[\"Bar\"].SetClass<Bar, int>(\"add_this\", &Bar::AddThis);\r\n```\r\n\r\n```lua\r\nbar = Bar.new(5)\r\n-- bar now refers to a new instance of Bar with its member x set to 5\r\n\r\nx = bar:add_this(2)\r\n-- x is now 7\r\n\r\nbar = nil\r\n--[[ the bar object will be destroyed the next time a garbage\r\n     collection is run ]]--\r\n```\r\n\r\nThe signature of the `SetClass` template method looks like the\r\nfollowing:\r\n\r\n```c++\r\ntemplate <typename T, typename... CtorArgs, typename... Funs>\r\nvoid Selector::SetClass(Funs... funs);\r\n```\r\n\r\nThe template parameters supplied explicitly are first `T`, the class\r\nyou wish to register followed by `CtorArgs...`, the types that are\r\naccepted by the class's constructor. In addition to primitive types,\r\nyou may also pass pointers or references to other types that have been\r\nor will be registered. Note that constructor overloading\r\nis not supported at this time. The arguments to the `SetClass`\r\nfunction are a list of member functions you wish to register (callable\r\nfrom Lua). The format is [function name, function pointer, ...].\r\n\r\nAfter a class is registered, C++ functions and methods can return\r\npointers or references to Lua, and the class metatable will be\r\nassigned correctly.\r\n\r\n#### Registering Class Member Variables\r\n\r\nFor convenience, if you pass a pointer to a member instead of a member\r\nfunction, Selene will automatically generate a setter and getter for\r\nthe member. The getter name is just the name of the member variable\r\nyou supply and the setter has \"set_\" prepended to that name.\r\n\r\n```c++\r\n// Define Bar as above\r\nsel::State state;\r\nstate[\"Bar\"].SetClass<Bar, int>(\"x\", &Bar::x);\r\n```\r\n\r\n```lua\r\n-- now we can do the following:\r\nbar = Bar.new(4)\r\n\r\nprint(bar:x()) -- will print '4'\r\n\r\nbar:set_x(-4)\r\nprint(bar:x()) -- will print '-4'\r\n```\r\n\r\nMember variables registered in this way which are declared `const`\r\nwill not have a setter generated for them.\r\n\r\n### Registering Object Instances\r\n\r\nYou can also register an explicit object which was instantiated from\r\nC++. However, this object cannot be inherited from and you are in\r\ncharge of the object's lifetime.\r\n\r\n```c++\r\nstruct Foo {\r\n    int x;\r\n    Foo(int x_) : x(x_) {}\r\n\r\n    int DoubleAdd(int y) { return 2 * (x + y); }\r\n    void SetX(int x_) { x = x_; }\r\n};\r\n\r\nsel::State state;\r\n\r\n// Instantiate a foo object with x initially set to 2\r\nFoo foo(2);\r\n\r\n// Binds the C++ instance foo to a table also called foo in Lua along\r\n// with the DoubleAdd method and variable x. Binding a member variable\r\n// will create a getter and setter as illustrated below.\r\n// The user is not required to bind all members\r\nstate[\"foo\"].SetObj(foo,\r\n                    \"double_add\", &Foo::DoubleAdd,\r\n                    \"x\", &Foo::x);\r\n\r\nassert(state[\"foo\"][\"x\"]() == 2);\r\n\r\nstate[\"foo\"][\"set_x\"](4);\r\nassert(foo.x == 4);\r\n\r\nint result = state[\"foo\"][\"double_add\"](3);\r\nassert(result == 14);\r\n```\r\n\r\nIn the above example, the functions `foo.double_add` and `foo.set_x`\r\nwill also be accessible from within Lua after registration occurs. As\r\nwith class member variables, object instance variables which are\r\n`const` will not have a setter generated for them.\r\n\r\n## Writeups\r\n\r\nYou can read more about this project in the three blogposts that describes it:\r\n\r\n- [first part](http://www.jeremyong.com/blog/2014/01/10/interfacing-lua-with-templates-in-c-plus-plus-11/).\r\n- [second part](http://www.jeremyong.com/blog/2014/01/14/interfacing-lua-with-templates-in-c-plus-plus-11-continued)\r\n- [third part](http://www.jeremyong.com/blog/2014/01/21/interfacing-lua-with-templates-in-c-plus-plus-11-conclusion)\r\n- [ref-qualifier usage](http://www.jeremyong.com/blog/2014/02/15/using-ref-qualifiers/)\r\n\r\nThere have been syntax changes in library usage but the underlying\r\nconcepts of variadic template use and generics is the same.\r\n\r\n## Roadmap\r\n\r\nThe following features are planned, although nothing is guaranteed:\r\n\r\n- Smarter Lua module loading\r\n- Hooks for module reloading\r\n- VS support\r\n","google":"10576233","note":"Don't delete this file! It's used internally to help with page regeneration."}